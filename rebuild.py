#!/usr/bin/python
import json
import textwrap
import sys
from itertools import groupby

import rados
import cephfs

PY2 = False

header='''"""
This file is automatically generated.

Do not modify.
"""
import sys
import functools
import warnings
import json

try:
    from typing import List
    from ceph.mon_command_api import CommandResult
except ImportError:
    pass

if sys.version_info > (3, 0):
    from typing import overload


def deprecated(func):
    @functools.wraps(func)
    def new_func(*args, **kwargs):
        warnings.simplefilter('always', DeprecationWarning)  # turn off filter
        warnings.warn("Call to deprecated function {}.".format(func.__name__),
                      category=DeprecationWarning,
                      stacklevel=2)
        warnings.simplefilter('default', DeprecationWarning)  # reset filter
        return func(*args, **kwargs)
    return new_func


class MonCommandApi(object):
    """
    MonCommandApi is a class that provides access to the whole Ceph command line API in a 
    type save way. 
    
    Usage:
    
    >>> import rados
    ... from ceph_command_api import MonCommandApi
    ... cluster = rados.Rados(conffile='/etc/ceph/ceph.conf')
    ... cluster.connect()
    ... print(MonCommandApi(cluster).version())
    """
    def __init__(self, rados):
        self._rados = rados
        
    def _mon_command(self, cmd, inbuf=b'', target=None):
        res = self._rados.mon_command(json.dumps(cmd), inbuf=inbuf, target=target)
        return CommandResult(*res)
'''

func_template = '''
def {}({}):
{}{}
    prefix = '{}'
    _args = {{'prefix': prefix, {}}}
    return self._mon_command(_args)
'''

footer = """
"""
def indent(s):
    return '\n'.join(' '*4 + l for l in s.splitlines())

def comment(s):
    return '\n'.join('# ' + l for l in s.splitlines())


class Flags:
    NOFORWARD = (1 << 0)
    OBSOLETE = (1 << 1)
    DEPRECATED = (1 << 2)
    MGR = (1<<3)
    POLL = (1 << 4)
    HIDDEN = (1 << 5)

    VALS = {
        NOFORWARD: 'no_forward',
        OBSOLETE: 'obsolete',
        DEPRECATED: 'deprecated',
        MGR: 'mgr',
        POLL: 'poll',
        HIDDEN: 'hidden',
    }

    def __init__(self, fs):
        self.fs = fs

    def __contains__(self, other):
        return other in str(self)

    def __str__(self):
        keys = Flags.VALS.keys()
        es = {Flags.VALS[k] for k in keys if self.fs & k == k}
        return ', '.join(es)



class Param(object):
    t = {
        'CephInt': 'int',
        'CephString': 'str',
        'CephChoices': 'str',
        'CephPgid': 'str',
        'CephOsdName': 'str',
        'CephPoolname': 'str',
        'CephObjectname': 'str',
        'CephUUID': 'str',
        'CephEntityAddr': 'str',
        'CephIPAddr': 'str',
        'CephName': 'str',
        'CephBool': 'bool',
        'CephFloat': 'float',
    }

    def __init__(self, type, name, who=None, n=None, req=True, range=None, strings=None, goodchars=None):
        self.type = type
        self.name = name
        self.who = who
        self.n = n == 'N'
        self.req = req != 'false'
        self.range = range
        self.strings = strings
        self.goodchars = goodchars

        assert who == None

    def safe_name(self):
        unsafe = ['from', 'class', 'id', 'type', 'property']
        return self.name + '_1' if self.name in unsafe else self.name

    def help(self):
        advanced = ''
        if self.type != 'CephString':
            advanced += self.type + ' '
        if self.range:
            advanced += 'range= ``{}`` '.format(self.range.replace('|', '..'))
        if self.strings:
            advanced += 'strings={} '.format(self.strings)
        if self.goodchars:
            advanced += 'goodchars= ``{}`` '.format(self.goodchars)
        if self.safe_name() != self.name:
            advanced += 'Real name is ``{}`` '.format(self.name)

        lines = textwrap.wrap(':param {}: {}'.format(self.safe_name(), advanced))
        return '\n    '.join(lines)

    def mk_default(self):
        if not self.req:
            return '=None'
        return ''

    def py_type(self):
        inner = Param.t[self.type]
        return 'List[{}]'.format(inner) if self.n else inner

    def mk_type(self):
        if PY2:
            return ''
        return ': ' + self.py_type()

    def mk_dict(self):
        return "'{}': {}".format(self.name, self.safe_name())

    def __str__(self):
        return '{}{}{}'.format(self.safe_name(), self.mk_type(), self.mk_default())

class FuncSig(object):
    def __init__(self, sig, help, module, perm, flags):
        self.sig = [s for s in sig if isinstance(s, str)]
        self.params = sorted([Param(**s) for s in sig if not isinstance(s, str)], key=lambda p: p.req, reverse=True)
        self.help = help
        self.module = module
        self.perm = perm
        self.flags = Flags(flags)
        self.needs_overload = False

    def name(self):
        return '_'.join([e.replace('-', '_') for e in self.sig])

    def prefix(self):
        return ' '.join(self.sig)

    def mk_params(self):
        if self.params:
            lines = textwrap.wrap('self, ' + ', '.join([str(p) for p in self.params]), width=60)
            return ('\n' + ' '*(5+len(self.name()))).join(lines)
        else:
            return 'self'

    def mk_param_help(self):
        return '\n'.join([f.help() for f in self.params])

    def mk_mk_dict(self):
        lines = textwrap.wrap(', '.join([p.mk_dict() for p in self.params]), width=60)
        return ('\n' + ' '*(8+5)).join(lines)

    def mk_type_hint(self):
        if PY2:
            return '# type: ({}) -> CommandResult\n'.format(', '.join([f.py_type() for f in self.params]))
        return ''

    def mk_doc_string(self):
        elems = ['Prefix: ``{}``'.format(self.prefix())]
        if self.help:
            elems.append(textwrap.fill(self.help))
        elems.append('module={} perm={} flags={}'.format(self.module, self.perm, str(self.flags)))
        if self.params:
            elems.append(self.mk_param_help())
        return indent('"""\n{}\n"""'.format('\n\n'.join(elems)))


    def __str__(self):
        out = func_template.format(self.name(), self.mk_params(), indent(self.mk_type_hint()), self.mk_doc_string(), self.prefix(), self.mk_mk_dict())
        if self.needs_overload:
            out = '\n@overload  # Python 3 only' + out
        if 'deprecated' in self.flags or 'obsolete' in self.flags:
            out = '\n@deprecated' + out
        if self.needs_overload and PY2:
            out = comment(out)
        return out


def set_overload(funcs):
    for k, g in groupby(funcs, key=lambda f: f.name()):
        g = list(g)
        if len(g) > 1:
            for f in g:
                f.needs_overload = True

def mk_sigs(cluster, f):
    ret, out, outs = run_command(cluster, {"prefix": "get_command_descriptions"})
    all = json.loads(out)
    sigs = [FuncSig(**e[1]) for e in all.items()]
    sigs = sorted(sigs, key=lambda f: f.sig)
    set_overload(sigs)

    f.write(header)
    f.write('\n'.join([indent(str(s)) for s in sigs]))
    f.write(footer)

def run_command(cluster_handle, cmd):
    return cluster_handle.mon_command(json.dumps(cmd), b'')

def main(conf, py_ver='3'):
    cluster = rados.Rados(conffile=conf)
    cluster.connect()
    global PY2
    PY2 = py_ver == '2'
    with open('ceph_command_api/_generated.py', 'w') as f:
        mk_sigs(cluster, f)

if __name__ == '__main__':
    main(*sys.argv[1:])
